Вариант 7. Имитация отжига для TSP


Код реализует метаэвристику — имитацию отжига для решения задачи коммивояжёра (TSP) с ручным вводом матрицы расстояний для 8 городов. Вот как работает этот алгоритм по шагам:

1. Ввод данных:
   - Пользователь вручную вводит матрицу расстояний размером 8x8, где каждый элемент описывает расстояние между двумя городами.

2. Инициализация:
   - Алгоритм создаёт случайный начальный маршрут — последовательность обхода всех городов без повторов.
   - Вычисляется длина этого начального маршрута.

3. Основной цикл имитации отжига:
   - Изначально температура установлена на 100.
   - Пока температура не снизится до очень малого значения (0.01), повторяются циклы с заданным количеством итераций (1000):
     - На каждой итерации создаётся новое соседнее решение маршрута путём 2-opt обмена (выбирается случайный промежуток городов, который разворачивается).
     - Вычисляется длина нового маршрута.
     - Рассчитывается разница по длине (дельта) между новым и текущим маршрутом.
     - Если новый маршрут короче, он принимается гарантированно.
     - Если новый маршрут длиннее, он принимается с вероятностью $$ e^{-\Delta/T} $$, где $$ \Delta $$ — ухудшение, $$ T $$ — текущая температура.
     - Такой подход (критерий Метрополиса) позволяет алгоритму избежать застревания в локальных оптимумах.
     - Если найден улучшенный маршрут (меньшая длина), он запоминается как лучший.

4. Охлаждение температуры:
   - После каждой группы итераций температура уменьшается на коэффициент 0.95, снижая вероятность принятия худших решений.

5. Аналитика:
   - Ведётся учёт числа улучшений маршрута при каждой температуре для оценки эффективности поиска.

6. Итог:
   - После завершения цикла выводится лучший найденный маршрут, его стоимость, и статистика улучшений по температурам.

Таким образом, код последовательно исследует пространство маршрутов, начиная с случайного обхода, постепенно "затвердевая" (охлаждаясь) и сужая область поиска к оптимальному или хорошему решению. 2-opt обмены обеспечивают эффективное исследование соседних решений. Параметры (начальная температура, коэффициент охлаждения, число итераций) регулируют баланс между глобальным поиском и локальной оптимизацией.

Общая временная сложность кода имитации отжига для задачи коммивояжёра примерно равна $$O(N^2 \times I)$$, где:
- $$N$$ — число городов (в данном случае 8),
- $$I$$ — общее количество итераций (число температурных шагов умноженное на итерации на каждой температуре).

Объяснение сложности:

1. На каждой итерации алгоритма создаётся соседнее решение с помощью 2-opt обмена. 2-opt обмен — операция, которая за $$O(1)$$ времени меняет порядок маршрута (переворачивание подотрезка списка).

2. Однако для оценки стоимости нового маршрута функция пересчитывает длину всего маршрута, что требует обхода всех городов, то есть $$O(N)$$.

3. Перебор по шагам температуры и итерациям внутри каждого шага даёт примерно $$I$$ запусков.

4. Кроме того, в данном коде выбор индексов для 2-opt занимает $$O(1)$$, но пересчёт стоимости маршрута — ключевая операция, влияющая на время.

В сумме общая сложность порядка $$O(N \times I)$$. Поскольку $$I$$ задаётся как число температурных шагов $$\times$$ итераций на каждом шаге, и при $$N=8$$ значение $$N^2$$ можно считать условно, иногда приводят сложность как $$O(N^2 \times I)$$ исходя из того, что 2-opt иногда трактуется как $$O(N^2)$$ при тщательном переборе пар.


7. Коэффициент аппроксимации для составления расписания.
Доказательство коэффициента аппроксимации для жадного алгоритма составления расписания (модель параллельных машин, задача $$P||C_{\max}$$) с $$m$$ машинами:

***

### Задача и алгоритм

Рассматриваем задачу распределения множества задач $$J$$ с известными временами выполнения $$p_j$$ на $$m$$ одинаковых параллельных машинах. Цель — минимизировать время выполнения всех задач (makespan) $$C_{\max}$$.

Жадный алгоритм (List Scheduling) работает так: задачи назначаются по очереди на машину с минимальной текущей загрузкой.

***

### Обозначения:

- $$m$$ — число машин
- $$p_j$$ — время выполнения задачи $$j$$
- $$P = \sum_{j} p_j$$ — общее время выполнения всех задач
- $$C_{\text{OPT}}$$ — оптимальное (минимальное) время выполнения (например, минимальный makespan)
- $$C_{\text{ALG}}$$ — время выполнения, которое выдаёт жадный алгоритм

***

### Известные нижние оценки $$C_{\text{OPT}}$$

1. На всякую машину приходится в среднем как минимум $$P/m$$ (если задача была идеально сбалансирована):
$$
C_{\text{OPT}} \geq \frac{P}{m}
$$

2. Оптимальное время не может быть меньше времени самой длинной задачи:
$$
C_{\text{OPT}} \geq \max_j p_j
$$

***

### Доказательство коэффициента аппроксимации

Обозначим, что последняя задача была назначена на машину, которая стала наиболее загруженной. Пусть:
- $$t$$ — время завершения всех задач, кроме последней, на этой машине в момент присвоения последней задачи,
- $$p_l$$ — время последней задачи.

Тогда итоговое время выполнения на данной машине:
$$
C_{\text{ALG}} = t + p_l
$$

По алгоритму при назначении последней задачи эта машина имела минимальную загрузку, значит:
$$
t \leq \frac{P - p_l}{m}
$$

Так как $$t$$ — минимум среди загрузок перед назначением последней задачи, то максимум нагрузки по другим машинам не меньше $$t$$, т.е.
$$
t \leq \min_{\text{машины}} \text{текущая загрузка} \leq \frac{P - p_l}{m}
$$

Из этого следует неравенство:
$$
C_{\text{ALG}} = t + p_l \leq \frac{P - p_l}{m} + p_l = \frac{P}{m} + \left(1 - \frac{1}{m}\right)p_l
$$

Поскольку $$C_\text{OPT} \geq \frac{P}{m}$$ и $$C_\text{OPT} \geq \max_j p_j \geq p_l$$, получаем:
$$
C_{\text{ALG}} \leq C_\text{OPT} + \left(1 - \frac{1}{m}\right) C_\text{OPT} = \left(2 - \frac{1}{m}\right) C_\text{OPT}
$$

Или в более знакомом виде:
$$
\frac{C_{\text{ALG}}}{C_{\text{OPT}}} \leq 2 \left(1 - \frac{1}{2m}\right) = 2 \left(1 - \frac{1}{m}\right)
$$

***

### Итог:

Коэффициент аппроксимации жадного алгоритма составляет
$$
\boxed{
2 \left(1 - \frac{1}{m}\right)
}
$$

То есть, жадный алгоритм гарантирует, что найденное время выполнения будет не более чем в $$2(1 - 1/m)$$ раз хуже оптимального.





